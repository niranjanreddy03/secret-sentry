"""
Vault Sentry - Report Generation Endpoints
"""

import io
from datetime import datetime, timedelta
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, status, Query
from fastapi.responses import StreamingResponse
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func
from pydantic import BaseModel
from loguru import logger
from reportlab.lib import colors
from reportlab.lib.pagesizes import A4
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image

from app.core.database import get_db
from app.core.security import get_current_user
from app.models.user import User
from app.models.scan import Scan, ScanStatus
from app.models.secret import Secret, RiskLevel


router = APIRouter()


# ============================================
# Pydantic Schemas
# ============================================

class ReportRequest(BaseModel):
    """Report generation request"""
    scan_id: Optional[str] = None
    start_date: Optional[datetime] = None
    end_date: Optional[datetime] = None
    include_resolved: bool = False


class ReportSummary(BaseModel):
    """Report summary data"""
    total_scans: int
    total_findings: int
    high_risk_count: int
    medium_risk_count: int
    low_risk_count: int
    resolved_count: int
    open_count: int
    top_secret_types: dict
    repositories_scanned: int
    average_risk_score: float


# ============================================
# PDF Generation Helper
# ============================================

def generate_pdf_report(
    user: User,
    summary: dict,
    findings: List[dict],
    report_date: datetime
) -> io.BytesIO:
    """Generate a PDF report"""
    buffer = io.BytesIO()
    doc = SimpleDocTemplate(
        buffer,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72
    )
    
    styles = getSampleStyleSheet()
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        textColor=colors.HexColor('#1a1a2e'),
        spaceAfter=30
    )
    heading_style = ParagraphStyle(
        'CustomHeading',
        parent=styles['Heading2'],
        fontSize=16,
        textColor=colors.HexColor('#16213e'),
        spaceAfter=12
    )
    normal_style = styles['Normal']
    
    elements = []
    
    # Title
    elements.append(Paragraph("üõ°Ô∏è Vault Sentry Security Report", title_style))
    elements.append(Spacer(1, 12))
    
    # Report metadata
    elements.append(Paragraph(f"<b>Generated:</b> {report_date.strftime('%Y-%m-%d %H:%M:%S UTC')}", normal_style))
    elements.append(Paragraph(f"<b>Generated by:</b> {user.email}", normal_style))
    elements.append(Spacer(1, 20))
    
    # Executive Summary
    elements.append(Paragraph("Executive Summary", heading_style))
    
    summary_data = [
        ["Metric", "Value"],
        ["Total Scans", str(summary.get('total_scans', 0))],
        ["Total Findings", str(summary.get('total_findings', 0))],
        ["High Risk Issues", str(summary.get('high_risk_count', 0))],
        ["Medium Risk Issues", str(summary.get('medium_risk_count', 0))],
        ["Low Risk Issues", str(summary.get('low_risk_count', 0))],
        ["Resolved Issues", str(summary.get('resolved_count', 0))],
        ["Open Issues", str(summary.get('open_count', 0))],
        ["Average Risk Score", f"{summary.get('average_risk_score', 0):.1f}%"],
    ]
    
    summary_table = Table(summary_data, colWidths=[3*inch, 2*inch])
    summary_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#1a1a2e')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor('#f8f9fa')),
        ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),
        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 1), (-1, -1), 10),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#dee2e6')),
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
    ]))
    elements.append(summary_table)
    elements.append(Spacer(1, 30))
    
    # Findings Table
    if findings:
        elements.append(Paragraph("Detailed Findings", heading_style))
        
        findings_data = [["File", "Type", "Risk", "Line", "Status"]]
        for finding in findings[:50]:  # Limit to first 50
            findings_data.append([
                finding.get('file_path', '')[-40:],  # Truncate long paths
                finding.get('type', ''),
                finding.get('risk_level', ''),
                str(finding.get('line_number', '')),
                finding.get('status', '')
            ])
        
        findings_table = Table(findings_data, colWidths=[2.5*inch, 1.2*inch, 0.8*inch, 0.5*inch, 0.8*inch])
        findings_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#1a1a2e')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 9),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
            ('BACKGROUND', (0, 1), (-1, -1), colors.white),
            ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),
            ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 1), (-1, -1), 8),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#dee2e6')),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#f8f9fa')]),
        ]))
        elements.append(findings_table)
    
    elements.append(Spacer(1, 30))
    
    # Footer
    elements.append(Paragraph(
        "<i>This report was automatically generated by Vault Sentry. "
        "For questions or support, contact your administrator.</i>",
        ParagraphStyle('Footer', parent=normal_style, fontSize=8, textColor=colors.gray)
    ))
    
    doc.build(elements)
    buffer.seek(0)
    return buffer


# ============================================
# Endpoints
# ============================================

@router.get("/summary", response_model=ReportSummary)
async def get_report_summary(
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get summary statistics for reports.
    """
    # Default date range: last 30 days
    if not end_date:
        end_date = datetime.utcnow()
    if not start_date:
        start_date = end_date - timedelta(days=30)
    
    # Total scans
    scans_query = select(func.count(Scan.id)).where(
        (Scan.user_id == current_user.id) &
        (Scan.created_at >= start_date) &
        (Scan.created_at <= end_date) &
        (Scan.status == ScanStatus.COMPLETED.value)
    )
    scans_result = await db.execute(scans_query)
    total_scans = scans_result.scalar() or 0
    
    # Total findings and counts
    findings_base_query = (
        select(Secret)
        .join(Scan, Secret.scan_id == Scan.id)
        .where(
            (Scan.user_id == current_user.id) &
            (Scan.created_at >= start_date) &
            (Scan.created_at <= end_date)
        )
    )
    
    # Total findings
    total_query = select(func.count(Secret.id)).select_from(findings_base_query.subquery())
    total_result = await db.execute(
        select(func.count(Secret.id))
        .join(Scan, Secret.scan_id == Scan.id)
        .where(
            (Scan.user_id == current_user.id) &
            (Scan.created_at >= start_date) &
            (Scan.created_at <= end_date)
        )
    )
    total_findings = total_result.scalar() or 0
    
    # Risk level counts
    risk_counts = {}
    for level in ['critical', 'high', 'medium', 'low']:
        result = await db.execute(
            select(func.count(Secret.id))
            .join(Scan, Secret.scan_id == Scan.id)
            .where(
                (Scan.user_id == current_user.id) &
                (Scan.created_at >= start_date) &
                (Scan.created_at <= end_date) &
                (Secret.risk_level == level)
            )
        )
        risk_counts[level] = result.scalar() or 0
    
    high_risk_count = risk_counts.get('critical', 0) + risk_counts.get('high', 0)
    medium_risk_count = risk_counts.get('medium', 0)
    low_risk_count = risk_counts.get('low', 0)
    
    # Status counts
    resolved_result = await db.execute(
        select(func.count(Secret.id))
        .join(Scan, Secret.scan_id == Scan.id)
        .where(
            (Scan.user_id == current_user.id) &
            (Secret.status == 'resolved')
        )
    )
    resolved_count = resolved_result.scalar() or 0
    
    open_result = await db.execute(
        select(func.count(Secret.id))
        .join(Scan, Secret.scan_id == Scan.id)
        .where(
            (Scan.user_id == current_user.id) &
            (Secret.status == 'open')
        )
    )
    open_count = open_result.scalar() or 0
    
    # Top secret types
    type_query = (
        select(Secret.type, func.count(Secret.id).label('count'))
        .join(Scan, Secret.scan_id == Scan.id)
        .where(Scan.user_id == current_user.id)
        .group_by(Secret.type)
        .order_by(func.count(Secret.id).desc())
        .limit(5)
    )
    type_result = await db.execute(type_query)
    top_secret_types = {row[0]: row[1] for row in type_result.all()}
    
    # Average risk score
    avg_query = (
        select(func.avg(Secret.risk_score))
        .join(Scan, Secret.scan_id == Scan.id)
        .where(Scan.user_id == current_user.id)
    )
    avg_result = await db.execute(avg_query)
    average_risk_score = avg_result.scalar() or 0
    
    # Unique repositories scanned
    repo_query = (
        select(func.count(func.distinct(Scan.repository_id)))
        .where(
            (Scan.user_id == current_user.id) &
            (Scan.repository_id != None)
        )
    )
    repo_result = await db.execute(repo_query)
    repositories_scanned = repo_result.scalar() or 0
    
    return ReportSummary(
        total_scans=total_scans,
        total_findings=total_findings,
        high_risk_count=high_risk_count,
        medium_risk_count=medium_risk_count,
        low_risk_count=low_risk_count,
        resolved_count=resolved_count,
        open_count=open_count,
        top_secret_types=top_secret_types,
        repositories_scanned=repositories_scanned,
        average_risk_score=float(average_risk_score)
    )


@router.post("/generate-pdf")
async def generate_pdf(
    request: ReportRequest,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Generate a PDF security report.
    """
    # Get summary data
    end_date = request.end_date or datetime.utcnow()
    start_date = request.start_date or (end_date - timedelta(days=30))
    
    # Build summary
    summary = {
        'total_scans': 0,
        'total_findings': 0,
        'high_risk_count': 0,
        'medium_risk_count': 0,
        'low_risk_count': 0,
        'resolved_count': 0,
        'open_count': 0,
        'average_risk_score': 0
    }
    
    # Get scan count
    scans_result = await db.execute(
        select(func.count(Scan.id)).where(
            (Scan.user_id == current_user.id) &
            (Scan.status == ScanStatus.COMPLETED.value)
        )
    )
    summary['total_scans'] = scans_result.scalar() or 0
    
    # Get findings
    findings_query = (
        select(Secret)
        .join(Scan, Secret.scan_id == Scan.id)
        .where(Scan.user_id == current_user.id)
        .order_by(Secret.risk_score.desc())
    )
    
    if request.scan_id:
        scan_result = await db.execute(
            select(Scan).where(
                (Scan.scan_id == request.scan_id) &
                (Scan.user_id == current_user.id)
            )
        )
        scan = scan_result.scalar_one_or_none()
        if scan:
            findings_query = findings_query.where(Secret.scan_id == scan.id)
    
    if not request.include_resolved:
        findings_query = findings_query.where(Secret.status != 'resolved')
    
    findings_result = await db.execute(findings_query.limit(100))
    findings = [s.to_dict() for s in findings_result.scalars().all()]
    
    # Count by risk level
    for finding in findings:
        summary['total_findings'] += 1
        if finding['risk_level'] in ['critical', 'high']:
            summary['high_risk_count'] += 1
        elif finding['risk_level'] == 'medium':
            summary['medium_risk_count'] += 1
        else:
            summary['low_risk_count'] += 1
        
        if finding['status'] == 'resolved':
            summary['resolved_count'] += 1
        else:
            summary['open_count'] += 1
    
    if findings:
        summary['average_risk_score'] = sum(f['risk_score'] for f in findings) / len(findings)
    
    # Generate PDF
    pdf_buffer = generate_pdf_report(
        user=current_user,
        summary=summary,
        findings=findings,
        report_date=datetime.utcnow()
    )
    
    filename = f"secret_sentry_report_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.pdf"
    
    return StreamingResponse(
        pdf_buffer,
        media_type="application/pdf",
        headers={
            "Content-Disposition": f"attachment; filename={filename}"
        }
    )
